
<h1>How to create a custom database</h1>

EukDetect relies on a database of eukaryotic marker genes. This can be generated by the user to include specific species, as long as these species have a corresponding NCBI taxonomy ID.

The process to generate a database is as follows:
- identify candidate genes in genomes of interest using BUSCO
- Cluster genes at >99% identity & identify species to remove, if any
- mask repetitive regions in genes
- remove genes that are highly masked or size outliers
- build alignment database from input fasta of genes
- create the following precomputed database files for eukdetect: `specific_and_inherited_markers_per_taxid.txt`, `busco_taxid_link.txt`, and `taxid_cumulativelength.txt`.
- store NCBI taxonomy database release to for ete3
- ideally, sanity check this database for any problematic markers by running the EukDetect pipeline with either real or simulated microbiome sequencing data.

More info on every step of this is below.


Requirements:
- accessory scripts in the eukdetect/makedb folder (the following instructions assume you have added this directory to your path. if not, run scripts by specifying absolute paths)
- biopython
- busco>=5.4.0
- cd-hit-est>=v4.8.1
- repeatmasker (I run RepeatMasker through the dfam-tetools container: https://github.com/Dfam-consortium/TETools)
- bedtools

<h2>Identifying candidate genes in genomes of interest</h2>
<h3>Run BUSCO</h3>
Gather genomes desired for database. Important note is that there can only be one genome representing a species taxID in the database

Run busco with a version greater than 5.4.0 on each genome, using Augustus instead of metaeuk, using a command similar to the following: 

`busco --lineage_dataset /path/to/eukaryota_odb10 -m geno -f --long --offline -i $genome -o $outdir/busco/ --augustus --long`

<h3>Extract BUSCO DNA sequences from genomes</h3>
The BUSCO pipeline is designed to output both DNA and protein fastas of the identified protein files. However, I have had issues with this, so I manually extract the buscos from the genome using bedtools. This process also assigns an informative name to each busco. The helper script for this step is `extract_buscos_from_genome_and_fulltable.py`, which will generate a bed file for each genome. `bedtools getfasta` is then run on each bedfile/genome pair to generate a BUSCO file with informative names.

For all the genomes you are interested in, create a tab delimited table that is structured as follows:
|Tab1|Tab2|Tab3|Tab4|Tab5|
|----|----|---|----|----|
|Species_name|prefix|/path/to/genome.fasta|/path/to/buscodir/run_eukaryota_odb10/full_table.tsv|/path/to/busco_output.txt|

The file in Tab 4 is the full path to the `full_table.tsv` output generated by BUSCO, and the file in tab 5 is the full path to an output file that will contain the BUSCO bedfile for that particular genome.

Then, run 'python extract_buscos_from_genome_and_fulltable.py [input_table] [busco_list]' to generate each bedfile.

For each bed file/genome pair, run the following command:
`bedtools getfasta -nameOnly -s -fi [genome.fasta] -bed [buscos.bed] | perl -pi -e 's/\(.\)//' > [buscos_dna.fasta]`

Then, concatenate all `buscos_dna.fasta` files together and move to clustering genes.

<h2>Clustering genes at >99% identity</h2>

<h3>Identifying species groups and choosing a representative</h3>

Read aligment based methods are not designed to distinguish very similar genomes from each other. When there are multiple species with identical or nearly identical genomes, EukDetect will not be able to distinguish between them. When building the database, genes that are >99% identical are collapsed either at the species level, the genus level, or are designated "multigenus_collapse". This can sometimes mask species that are important to present: for example, hybrids of S. cerevisiae present in the NCBI genome database are removed from the EukDetect database to prevent a genus-level collapse of the informativeness of S. cerevisiae genes.

To determine whether you want to remove any of your genomes before proceeding, in this step we identify groups of species that are too similar to distinguish. The first step is to run cd-hit, and then run several accessory scripts that parse the cd-hit output.

`cd-hit-est -d 0 -i [buscos.fasta] -o buscos_cdhit99.fasta -c 0.99 -T [threads] -M [memory]`

This creates the output files `busco_cdhit99.fasta`, with one single representative for each cd-hit cluster, and `busco_cdhit99.fasta.clstr`, which includes information from cd-hit about which genes went into each cluster. The following command removes all single-gene clusters:

`get_spcluster_from_cdhit.py buscos_cdhit99.fasta.clstr > buscos_cdhit99_spclusters.txt`

To parse this into a readable format that is used by downstream parts of the eukdetect database creation pipeline, run:

`count_same_species_clusters_and_remove_multigroup.py buscos_cdhit99_spclusters.txt > buscos_cdhit99_cluster_list.txt`

This step will also discard genes that are clustering at >99% identity across different prefix groups, implying there is an error in their taxonomic assignment.

Finally, to create a human-readable table that tells you the number of collapsed genes per species and which species it overlaps with, run:

`count_grouped_genes.py buscos_cdhit99_cluster_list.txt > buscos_cdhit99_collapsed_counts_info.txt`

Look through the output of the final table and determine whether you would like to remove any species from downstream analyses. If so, remove genes belonging to those species from the fasta file, and re-run all previous steps in clustering.

Once you have removed the species you want to remove, you will now rename the cd-hit clustered genes with informative names. The options are _SSCollapse (clustered genes are all from the same species), _SPCollapse (clustered genes are all from the same genus), and _MGCollapse (clustered genes are from multiple genuses).

`rename_cdhit_collapsed.py buscos_rmsp_cdhit99_cluster_list.txt buscos_rmsp_cdhit99.fasta > buscos_rmsp_cdhit99_renamed.fasta`

<h2>Masking clustered database</h2>








